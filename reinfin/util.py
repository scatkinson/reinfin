import logging
import os
from datetime import date
import time
import random
import string
import itertools
import copy
import inspect
import numpy as np
import matplotlib.pyplot as plt

from typing import Tuple


def get_pipeline_id(user: str = "") -> str:
    if not user:
        user = os.getlogin()
    user.replace(".", "")

    today = date.today()
    today_str = today.strftime("%Y%m%d")

    random.seed(int(time.time() * 1000) % 2**32)
    rand_str = "".join(
        random.choices(population=string.ascii_letters + string.digits, k=4)
    )

    return "_".join([user, today_str, rand_str])


def get_elapsed_time(elapsed_time: float) -> Tuple[float, str]:
    """Description:
        The function converts a number of seconds into either minutes, hours, or days
        and returns the converted value rounded to 3 significant digits and an appropriate
        word either seconds, minutes, hours, or days based on the number of seconds given.

    Parameters:
        elapsed_time (int):
            An integer representing the number of seconds

    Returns:
        time_took_tuple (tuple):
            A tuple containing a floating value and an appropriate word,
            which is either seconds, minutes, hours, or days

    """

    time_took_str = "seconds"

    if elapsed_time > 60 * 60 * 24:
        elapsed_time = round(elapsed_time / (60 * 60 * 24), 3)
        time_took_str = "days"

    elif elapsed_time > 60 * 60:
        elapsed_time = round(elapsed_time / (60 * 60), 3)
        time_took_str = "hours"

    elif elapsed_time > 60:
        elapsed_time = round(elapsed_time / 60, 3)
        time_took_str = "minutes"

    return elapsed_time, time_took_str


def get_flat_list(nested_list: list) -> list:
    """Description:
        The function flattens a given nested list and
        returns a new flat list.

    Parameters:
        nested_list (list):
            A nested list of object that needs to be flattened
    Returns:
        flat_list (list):
            A flattened version of the nested list provided as a parameter to the function
    """

    # Flattenining list of submission objects

    flat_list = copy.deepcopy(nested_list)
    if len(flat_list) > 0:
        first_element = flat_list[0]

        while isinstance(first_element, list):
            flat_list = list(itertools.chain(*flat_list))
            if len(flat_list) > 0:
                first_element = flat_list[0]
            else:
                first_element = None

    return flat_list


def return_updated_dict(d, u):
    """

    Args:
        d: dict to be updated
        u: single-key dict to be appended to d

    Returns: updated dict

    """
    d.update(u)
    return d


def timed_operation(func=None, *, custom_msg_func=None):
    """Description:
        Decorator to measure and optionally print the execution time of a function.

    Parameters:
        func (callable, optional):
            The function to wrap (used for @timed_operation and @timed_operation()).
        custom_msg_func (callable, optional):
            A function generated by `create_message_function` to format timing output.

    Returns:
        callable: The wrapped function with optional timing output.

    Usage:
        @timed_operation
        def foo(): ...

        or

        msg = create_message_function("...", ...)
        @timed_operation(custom_msg_func=msg)
        def bar(): ...

        # To print the message, call the function with print_msg=True
        bar(..., print_msg=True)
    """

    def decorator(func):
        def wrapper(*args, **kwargs):
            # Extract print_msg from kwargs or use default False
            print_msg = (
                kwargs.pop("print_msg", False) if "print_msg" in kwargs else False
            )

            s = time.time()
            result = func(*args, **kwargs)
            e = time.time()

            if print_msg:
                time_took, time_took_str = get_elapsed_time(e - s)

                if custom_msg_func:
                    # Use custom message function
                    msg = custom_msg_func(
                        func, time_took, time_took_str, result, *args, **kwargs
                    )
                else:
                    # Default message
                    msg = f"{func.__name__} took {time_took} {time_took_str}"
                    if hasattr(result, "__len__"):
                        msg += f" to process {len(result)} items"
                    msg += "\n" + "-" * 115

                print(msg)
            return result

        return wrapper

    if func is None:
        return decorator
    return decorator(func)


def create_message_function(format_string, *param_names, unit=None):
    """Description:
        Factory to generate a custom timing message formatter for the
        `timed_operation` decorator.

    Parameters:
        format_string (str):
            A format string with placeholders (e.g.,
            "{func_call} took {time_took} {time_took_str}").
        *param_names (str):
            Names of function arguments to extract and include in the
            formatted message.

    Returns:
        function:
            A custom message function that can be passed to `timed_operation`.

    Available placeholders in `format_string`:
        - {func_name}: Name of the function (e.g., 'get_data')
        - {func_call}: Formatted function call with parameter names
                        (e.g., 'get_data(user_id, start_date)')
        - {time_took}: Elapsed time as a float in seconds
        - {time_took_str}: Human-readable version of time (e.g., '12.3 s')
        - {result_len}: Length of the return value if applicable
        - {your_param}: Any additional arguments listed in *param_names

    Example:
        user_msg = create_message_function(
            "{func_call} took {time_took} {time_took_str} to extract
            {result_len} records for user {user_name}",
            "user_name"
        )

        @timed_operation(custom_msg_func=user_msg)
        def get_user_data(api, user_name): ...
    """

    def message_func(func, time_took, time_took_str, result, *args, **kwargs):
        # Map args/kwargs to parameter names using signature
        bound = inspect.signature(func).bind_partial(*args, **kwargs)
        bound.apply_defaults()

        params = {}

        for name in param_names:
            val = bound.arguments.get(name)

            # Format list parameters
            if isinstance(val, list):
                params[name] = format_param_list(val, unit if name == "names" else None)
            elif val is not None:
                params[name] = str(val)
            else:
                params[name] = "None"

        # Standard fields
        params.update(
            {
                "func_name": func.__name__,
                "func_call": (
                    f"{func.__name__}({', '.join(inspect.signature(func).parameters.keys())})"
                ),
                "time_took": time_took,
                "time_took_str": time_took_str,
                "result_len": len(result) if hasattr(result, "__len__") else 0,
            }
        )

        msg = format_string.format(**params)
        msg += "\n" + "-" * 115
        return msg

    return message_func


def format_param_list(values, unit=None):
    """
    Format a list of string values into a readable summary string.

    If the list is empty, it returns a count (with or without a unit).
    If the list has one or two items, it joins them with commas.
    If the list has more than two items, it shows the first two and summarizes the rest as "X other(s)".

    Args:
        values (list): A list of strings to format.
        unit (str, optional): A word describing the type of item (e.g., 'user', 'subreddit').
                              Used in pluralization of the summary.

    Returns:
        str: A human-readable summary string representing the list.
    """
    count = len(values)
    if count == 0:
        return f"0 {unit}s" if unit else "0 items"
    if count == 1:
        return f"{values[0]}" + (f" {unit}" if unit else "")
    if count == 2:
        return f"{values[0]} and {values[1]}" + (f" {unit}s" if unit else "")

    first_two = ", ".join(values[:2])
    others_count = count - 2
    if unit:
        other_unit = f"{others_count} other {unit}" + ("s" if others_count > 1 else "")
        return f"{first_two}, and {other_unit}"
    else:
        return f"{first_two}, and {others_count} others"

    import matplotlib.pyplot as plt
    import numpy as np


def plot_learning_curve(scores, figure_file):
    plt.clf()
    running_avg = np.zeros(len(scores))
    for i in range(len(running_avg)):
        running_avg[i] = np.mean(scores[max(0, i - 100) : (i + 1)])
    plt.plot(running_avg)
    plt.title("Running average of previous 100 episodes")
    plt.savefig(figure_file)


def plot_curve(scores, figure_file):
    plt.clf()
    x = [i + 1 for i in range(len(scores))]
    plt.plot(x, scores)
    plt.savefig(figure_file)
